<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Glorious Battery Monitor</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%2360a5fa' stroke-width='2'><rect x='2' y='7' width='18' height='11' rx='2'/><path d='M22 10v4'/></svg>">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        fluent: {
                            bg: '#f3f3f3',
                            card: '#ffffff',
                            text: '#242424',
                            muted: '#605e5c',
                            border: '#e1dfdd',
                            accent: '#0078d4',
                            'accent-hover': '#106ebe',
                            success: '#107c10',
                            warning: '#faa500',
                            danger: '#d13438',
                            charging: '#0078d4',
                        },
                        'fluent-dark': {
                            bg: '#1e1e1e',
                            card: '#2d2d2d',
                            text: '#ffffff',
                            muted: '#a19f9d',
                            border: '#3d3d3d',
                            accent: '#60a5fa',
                            'accent-hover': '#3b82f6',
                            success: '#6ccf59',
                            warning: '#faa500',
                            danger: '#f87171',
                            charging: '#60a5fa',
                        }
                    }
                }
            }
        }
    </script>
    <style>
        /* System theme detection and initialization */
        @media (prefers-color-scheme: dark) {
            html:not(.light) { color-scheme: dark; }
        }
        
        /* Smooth transitions */
        * {
            transition-property: background-color, border-color, color, fill, stroke;
            transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
            transition-duration: 150ms;
        }
        
        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: transparent;
        }
        
        ::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }
        
        .dark ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
        }
        
        /* Battery ring animation */
        .battery-ring {
            transition: stroke-dashoffset 0.6s cubic-bezier(0.4, 0, 0.2, 1),
                        stroke 0.3s ease;
        }
        
        /* Sparkline */
        .sparkline-path {
            vector-effect: non-scaling-stroke;
            transition: d 0.3s ease;
        }
        
        /* Modal backdrop blur */
        .modal-backdrop {
            backdrop-filter: blur(4px);
        }
        
        /* Toast animation */
        @keyframes slide-in {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes slide-out {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }
        
        .toast-enter {
            animation: slide-in 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .toast-exit {
            animation: slide-out 0.2s cubic-bezier(0.4, 0, 1, 1);
        }
        
        /* Focus styles */
        .focus-ring:focus-visible {
            outline: 2px solid;
            outline-offset: 2px;
        }
        
        .light .focus-ring:focus-visible {
            outline-color: #0078d4;
        }
        
        .dark .focus-ring:focus-visible {
            outline-color: #60a5fa;
        }
        
        /* Button press effect */
        .btn-press:active {
            transform: scale(0.98);
        }
        
        /* Prevent text selection on UI elements */
        .no-select {
            user-select: none;
        }
    </style>
</head>
<body class="light bg-fluent-bg dark:bg-fluent-dark-bg transition-colors duration-200 overflow-hidden">
    <!-- Update Banner -->
    <div id="updateBanner" class="hidden bg-gradient-to-r from-blue-500 to-blue-600 dark:from-blue-600 dark:to-blue-700 text-white px-6 py-3 flex items-center justify-between shadow-lg">
        <div class="flex items-center gap-3">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/>
            </svg>
            <div>
                <div class="font-semibold text-sm">Update Available</div>
                <div id="updateVersion" class="text-xs opacity-90"></div>
            </div>
        </div>
        <button id="updateBtn" onclick="installUpdate()" class="px-4 py-1.5 bg-white/20 hover:bg-white/30 rounded-lg text-sm font-semibold transition focus-ring" aria-label="Install update">
            Install Now
        </button>
    </div>

    <!-- Main Container -->
    <div class="h-screen flex flex-col overflow-hidden">
        <!-- Header -->
        <header class="bg-fluent-card dark:bg-fluent-dark-card border-b border-fluent-border dark:border-fluent-dark-border px-6 py-4 flex items-center justify-between no-select">
            <div class="flex items-center gap-3">
                <svg class="w-6 h-6 text-fluent-accent dark:text-fluent-dark-accent" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <rect x="2" y="7" width="18" height="11" rx="2"/>
                    <path d="M22 10v4"/>
                </svg>
                <div>
                    <h1 id="deviceTitle" class="text-lg font-semibold text-fluent-text dark:text-fluent-dark-text">Glorious Mouse</h1>
                    <p class="text-xs text-fluent-muted dark:text-fluent-dark-muted">Battery Monitor</p>
                </div>
            </div>
            <div class="flex items-center gap-2">
                <button id="themeToggle" onclick="toggleTheme()" class="p-2 rounded-lg hover:bg-fluent-bg dark:hover:bg-fluent-dark-bg transition btn-press focus-ring" aria-label="Toggle theme">
                    <svg class="w-5 h-5 text-fluent-muted dark:text-fluent-dark-muted hidden dark:block" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"/>
                    </svg>
                    <svg class="w-5 h-5 text-fluent-muted dark:text-fluent-dark-muted block dark:hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"/>
                    </svg>
                </button>
                <button onclick="openSettings()" class="p-2 rounded-lg hover:bg-fluent-bg dark:hover:bg-fluent-dark-bg transition btn-press focus-ring" aria-label="Open settings">
                    <svg class="w-5 h-5 text-fluent-muted dark:text-fluent-dark-muted" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"/>
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
                    </svg>
                </button>
            </div>
        </header>

        <!-- Main Content -->
        <main class="flex-1 overflow-y-auto px-6 py-6">
            <div class="max-w-md mx-auto space-y-6">
                <!-- Battery Gauge -->
                <div class="bg-fluent-card dark:bg-fluent-dark-card rounded-2xl shadow-sm border border-fluent-border dark:border-fluent-dark-border p-8">
                    <div class="flex flex-col items-center">
                        <!-- Battery Ring -->
                        <div class="relative w-48 h-48 mb-6">
                            <svg class="w-full h-full -rotate-90" viewBox="0 0 200 200" aria-hidden="true">
                                <circle cx="100" cy="100" r="85" fill="none" stroke="currentColor" stroke-width="12" class="text-fluent-border dark:text-fluent-dark-border opacity-30"/>
                                <circle id="batteryRing" cx="100" cy="100" r="85" fill="none" stroke="currentColor" stroke-width="12" stroke-linecap="round" class="battery-ring text-fluent-accent dark:text-fluent-dark-accent" style="stroke-dasharray: 534.07; stroke-dashoffset: 534.07;"/>
                            </svg>
                            <div class="absolute inset-0 flex flex-col items-center justify-center">
                                <div id="batteryIcon" class="mb-2">
                                    <svg class="w-12 h-12 text-fluent-text dark:text-fluent-dark-text" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <rect x="2" y="7" width="18" height="11" rx="2"/>
                                        <path d="M22 10v4"/>
                                    </svg>
                                </div>
                                <div id="batteryLevel" class="text-4xl font-bold text-fluent-text dark:text-fluent-dark-text" aria-live="polite">--</div>
                            </div>
                        </div>
                        
                        <!-- Status Badge -->
                        <div id="statusBadge" class="px-4 py-2 rounded-full text-sm font-semibold bg-fluent-border/20 dark:bg-fluent-dark-border/20 text-fluent-muted dark:text-fluent-dark-muted">
                            <span id="statusText">Connecting...</span>
                        </div>
                    </div>
                </div>

                <!-- Info Cards -->
                <div class="grid grid-cols-2 gap-4">
                    <div class="bg-fluent-card dark:bg-fluent-dark-card rounded-xl shadow-sm border border-fluent-border dark:border-fluent-dark-border p-4">
                        <div class="text-xs font-semibold text-fluent-muted dark:text-fluent-dark-muted uppercase tracking-wide mb-2">Last Charged</div>
                        <div id="lastCharge" class="text-lg font-bold text-fluent-text dark:text-fluent-dark-text">Never</div>
                    </div>
                    <div class="bg-fluent-card dark:bg-fluent-dark-card rounded-xl shadow-sm border border-fluent-border dark:border-fluent-dark-border p-4">
                        <div class="text-xs font-semibold text-fluent-muted dark:text-fluent-dark-muted uppercase tracking-wide mb-2">Charged To</div>
                        <div id="chargeLevel" class="text-lg font-bold text-fluent-text dark:text-fluent-dark-text">--</div>
                    </div>
                </div>

                <!-- Time Remaining Card -->
                <div id="timeRemainingCard" class="hidden bg-fluent-card dark:bg-fluent-dark-card rounded-xl shadow-sm border border-fluent-border dark:border-fluent-dark-border p-4">
                    <div class="flex items-center justify-between mb-2">
                        <div class="text-xs font-semibold text-fluent-muted dark:text-fluent-dark-muted uppercase tracking-wide">
                            <span id="timeLabel">Time Remaining</span>
                        </div>
                        <button onclick="toggleTimeTooltip()" class="text-fluent-muted dark:text-fluent-dark-muted hover:text-fluent-text dark:hover:text-fluent-dark-text transition focus-ring rounded" aria-label="More information">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                            </svg>
                        </button>
                    </div>
                    <div id="timeRemaining" class="text-2xl font-bold text-fluent-text dark:text-fluent-dark-text">--</div>
                </div>

            </div>
        </main>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="hidden fixed inset-0 z-50 overflow-y-auto modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="settingsTitle">
        <div class="flex items-center justify-center min-h-screen p-4">
            <div class="fixed inset-0 bg-black/50 dark:bg-black/70 transition-opacity" onclick="closeSettings()"></div>
            <div class="relative bg-fluent-card dark:bg-fluent-dark-card rounded-2xl shadow-xl border border-fluent-border dark:border-fluent-dark-border max-w-lg w-full max-h-[90vh] overflow-y-auto">
                <div class="sticky top-0 bg-fluent-card dark:bg-fluent-dark-card border-b border-fluent-border dark:border-fluent-dark-border px-6 py-4 flex items-center justify-between">
                    <h2 id="settingsTitle" class="text-xl font-bold text-fluent-text dark:text-fluent-dark-text">Settings</h2>
                    <button onclick="closeSettings()" class="p-2 hover:bg-fluent-bg dark:hover:bg-fluent-dark-bg rounded-lg transition focus-ring" aria-label="Close">
                        <svg class="w-5 h-5 text-fluent-muted dark:text-fluent-dark-muted" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                        </svg>
                    </button>
                </div>
                
                <div class="p-6 space-y-6">
                    <p class="text-sm text-fluent-muted dark:text-fluent-dark-muted">Configure startup behavior, polling intervals, and battery alerts.</p>
                    
                    <!-- Checkboxes -->
                    <div class="space-y-3">
                        <label class="flex items-center gap-3 cursor-pointer group">
                            <input type="checkbox" id="startWithWindows" class="w-5 h-5 rounded border-fluent-border dark:border-fluent-dark-border text-fluent-accent dark:text-fluent-dark-accent focus-ring">
                            <span class="text-sm font-medium text-fluent-text dark:text-fluent-dark-text group-hover:text-fluent-accent dark:group-hover:text-fluent-dark-accent transition">Start with Windows</span>
                        </label>
                        <label class="flex items-center gap-3 cursor-pointer group">
                            <input type="checkbox" id="startMinimized" class="w-5 h-5 rounded border-fluent-border dark:border-fluent-dark-border text-fluent-accent dark:text-fluent-dark-accent focus-ring">
                            <span class="text-sm font-medium text-fluent-text dark:text-fluent-dark-text group-hover:text-fluent-accent dark:group-hover:text-fluent-dark-accent transition">Start Minimized</span>
                        </label>
                        <label class="flex items-center gap-3 cursor-pointer group">
                            <input type="checkbox" id="nonIntrusiveMode" class="w-5 h-5 rounded border-fluent-border dark:border-fluent-dark-border text-fluent-accent dark:text-fluent-dark-accent focus-ring">
                            <span class="text-sm font-medium text-fluent-text dark:text-fluent-dark-text group-hover:text-fluent-accent dark:group-hover:text-fluent-dark-accent transition">Non-intrusive mode</span>
                        </label>
                        <p class="text-xs text-fluent-muted dark:text-fluent-dark-muted ml-8">Legacy power-saving behavior</p>
                        
                        <label class="flex items-center gap-3 cursor-pointer group">
                            <input type="checkbox" id="safeMode" class="w-5 h-5 rounded border-fluent-border dark:border-fluent-dark-border text-fluent-accent dark:text-fluent-dark-accent focus-ring">
                            <span class="text-sm font-medium text-fluent-text dark:text-fluent-dark-text group-hover:text-fluent-accent dark:group-hover:text-fluent-dark-accent transition">Safe HID mode</span>
                        </label>
                        <p class="text-xs text-fluent-muted dark:text-fluent-dark-muted ml-8">Read-only probing, limits HID access</p>
                        
                        <label class="flex items-center gap-3 cursor-pointer group">
                            <input type="checkbox" id="notificationsEnabled" class="w-5 h-5 rounded border-fluent-border dark:border-fluent-dark-border text-fluent-accent dark:text-fluent-dark-accent focus-ring">
                            <span class="text-sm font-medium text-fluent-text dark:text-fluent-dark-text group-hover:text-fluent-accent dark:group-hover:text-fluent-dark-accent transition">Enable Notifications</span>
                        </label>
                        
                        <label class="flex items-center gap-3 cursor-pointer group">
                            <input type="checkbox" id="showPercentageOnIcon" class="w-5 h-5 rounded border-fluent-border dark:border-fluent-dark-border text-fluent-accent dark:text-fluent-dark-accent focus-ring">
                            <span class="text-sm font-medium text-fluent-text dark:text-fluent-dark-text group-hover:text-fluent-accent dark:group-hover:text-fluent-dark-accent transition">Show percentage on tray icon</span>
                        </label>
                        <p class="text-xs text-fluent-muted dark:text-fluent-dark-muted ml-8">Display battery percentage overlay</p>
                    </div>
                    
                    <!-- Number Inputs -->
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label for="refreshInterval" class="block text-sm font-medium text-fluent-text dark:text-fluent-dark-text mb-2">Refresh Interval (s)</label>
                            <input type="number" id="refreshInterval" min="1" max="60" class="w-full px-3 py-2 bg-fluent-bg dark:bg-fluent-dark-bg border border-fluent-border dark:border-fluent-dark-border rounded-lg text-fluent-text dark:text-fluent-dark-text focus-ring">
                            <p class="text-xs text-fluent-muted dark:text-fluent-dark-muted mt-1">Polling frequency</p>
                        </div>
                        <div>
                            <label for="lowBatteryThreshold" class="block text-sm font-medium text-fluent-text dark:text-fluent-dark-text mb-2">Low Battery (%)</label>
                            <input type="number" id="lowBatteryThreshold" min="5" max="50" class="w-full px-3 py-2 bg-fluent-bg dark:bg-fluent-dark-bg border border-fluent-border dark:border-fluent-dark-border rounded-lg text-fluent-text dark:text-fluent-dark-text focus-ring">
                            <p class="text-xs text-fluent-muted dark:text-fluent-dark-muted mt-1">Warning threshold</p>
                        </div>
                    </div>
                    
                    <div>
                        <label for="criticalBatteryThreshold" class="block text-sm font-medium text-fluent-text dark:text-fluent-dark-text mb-2">Critical Battery (%)</label>
                        <input type="number" id="criticalBatteryThreshold" min="5" max="30" class="w-full px-3 py-2 bg-fluent-bg dark:bg-fluent-dark-bg border border-fluent-border dark:border-fluent-dark-border rounded-lg text-fluent-text dark:text-fluent-dark-text focus-ring">
                        <p class="text-xs text-fluent-muted dark:text-fluent-dark-muted mt-1">Critical alert threshold</p>
                    </div>
                    
                    <!-- Developer Tools -->
                    <div class="border border-fluent-border dark:border-fluent-dark-border rounded-xl p-4 space-y-4">
                        <div class="flex items-center gap-2">
                            <svg class="w-5 h-5 text-fluent-accent dark:text-fluent-dark-accent" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"/>
                            </svg>
                            <h3 class="text-sm font-bold text-fluent-text dark:text-fluent-dark-text">Developer Tools</h3>
                        </div>
                        <p class="text-xs text-fluent-muted dark:text-fluent-dark-muted">Scan HID devices or capture reports for diagnostics</p>
                        <div class="flex flex-wrap gap-2">
                            <button onclick="scanHIDDevices()" class="px-4 py-2 bg-fluent-bg dark:bg-fluent-dark-bg hover:bg-fluent-border/30 dark:hover:bg-fluent-dark-border/30 border border-fluent-border dark:border-fluent-dark-border rounded-lg text-sm font-semibold text-fluent-text dark:text-fluent-dark-text transition btn-press focus-ring">
                                Scan HID
                            </button>
                            <button onclick="captureHidReport()" class="px-4 py-2 bg-fluent-bg dark:bg-fluent-dark-bg hover:bg-fluent-border/30 dark:hover:bg-fluent-dark-border/30 border border-fluent-border dark:border-fluent-dark-border rounded-lg text-sm font-semibold text-fluent-text dark:text-fluent-dark-text transition btn-press focus-ring">
                                Capture Report
                            </button>
                            <button id="copyHidBtn" onclick="copyHidReport()" disabled class="px-4 py-2 bg-fluent-bg dark:bg-fluent-dark-bg hover:bg-fluent-border/30 dark:hover:bg-fluent-dark-border/30 border border-fluent-border dark:border-fluent-dark-border rounded-lg text-sm font-semibold text-fluent-text dark:text-fluent-dark-text transition btn-press focus-ring disabled:opacity-50 disabled:cursor-not-allowed">
                                Copy Output
                            </button>
                        </div>
                        
                        <!-- Diagnostics Export -->
                        <div class="border-t border-fluent-border dark:border-fluent-dark-border mt-4 pt-4">
                            <div class="flex items-center gap-2 mb-2">
                                <svg class="w-4 h-4 text-fluent-accent dark:text-fluent-dark-accent" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
                                </svg>
                                <h4 class="text-sm font-semibold text-fluent-text dark:text-fluent-dark-text">Device Diagnostics</h4>
                            </div>
                            <p class="text-xs text-fluent-muted dark:text-fluent-dark-muted mb-3">Export device information for support (read-only, PII sanitized)</p>
                            
                            <label class="flex items-center gap-2 cursor-pointer group mb-3">
                                <input type="checkbox" id="includeExperimental" class="w-4 h-4 rounded border-fluent-border dark:border-fluent-dark-border text-fluent-accent dark:text-fluent-dark-accent focus:ring-2 focus:ring-fluent-accent/50">
                                <span class="text-sm text-fluent-text dark:text-fluent-dark-text group-hover:text-fluent-accent dark:group-hover:text-fluent-dark-accent transition">Include experimental vendor reads</span>
                            </label>
                            <p class="text-xs text-yellow-600 dark:text-yellow-400 mb-3 ml-6">⚠️ May trigger device responses - use with caution</p>
                            
                            <button onclick="captureDiagnostics()" class="px-4 py-2 bg-fluent-accent dark:bg-fluent-dark-accent hover:bg-fluent-accent-hover dark:hover:bg-fluent-dark-accent-hover text-white rounded-lg text-sm font-semibold transition btn-press focus-ring">
                                <span id="diagnosticsSpinner" class="hidden">⏳</span>
                                <span id="diagnosticsText">Capture Diagnostics</span>
                            </button>
                        </div>
                        <div id="devStatus" class="text-xs text-fluent-muted dark:text-fluent-dark-muted" aria-live="polite">No scan yet</div>
                        <pre id="hidDump" class="hidden mt-2 p-3 bg-fluent-bg dark:bg-fluent-dark-bg border border-fluent-border dark:border-fluent-dark-border rounded-lg text-xs text-fluent-text dark:text-fluent-dark-text overflow-auto max-h-48 font-mono"></pre>
                    </div>
                </div>
                
                <div class="sticky bottom-0 bg-fluent-card dark:bg-fluent-dark-card border-t border-fluent-border dark:border-fluent-dark-border px-6 py-4 flex justify-end gap-3">
                    <button onclick="closeSettings()" class="px-6 py-2 bg-fluent-bg dark:bg-fluent-dark-bg hover:bg-fluent-border/30 dark:hover:bg-fluent-dark-border/30 border border-fluent-border dark:border-fluent-dark-border rounded-lg text-sm font-semibold text-fluent-text dark:text-fluent-dark-text transition btn-press focus-ring">
                        Cancel
                    </button>
                    <button id="saveBtn" onclick="saveSettings()" class="px-6 py-2 bg-fluent-accent dark:bg-fluent-dark-accent hover:bg-fluent-accent-hover dark:hover:bg-fluent-dark-accent-hover text-white rounded-lg text-sm font-semibold transition btn-press focus-ring">
                        <span id="saveSpinner" class="hidden">⏳</span>
                        <span id="saveText">Save</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast Container -->
    <div id="toastContainer" class="fixed bottom-6 right-6 z-50 space-y-3" aria-live="polite" aria-atomic="true"></div>

    <!-- Tooltip -->
    <div id="timeTooltip" class="hidden fixed z-50 max-w-xs p-3 bg-fluent-card dark:bg-fluent-dark-card border border-fluent-border dark:border-fluent-dark-border rounded-lg shadow-xl text-xs text-fluent-text dark:text-fluent-dark-text">
        This estimate is based on your current battery rate. It may show "Calculating..." until enough data is collected (requires at least 3% battery change).
    </div>

    <script>
        // ======================
        // State Management
        // ======================
        let currentSettings = {};
        let historyState = {
            range: '24h',
            currentVersion: 0,
            renderedVersion: 0,
            points: [],
            events: [],
            from: 0,
            to: 0,
            hoverIndex: null,
            fetching: false,
            pendingVersion: false,
        };
        let historyFetchTimer = null;
        let historyCanvas = null;
        let historyCtx = null;
        let historyTooltip = null;
        let historySummaryEl = null;
        let historyDetailEl = null;
        let historyUpdatedEl = null;
        let historyRangeButtons = [];
        let historyContainer = null;
        let lastHidDump = '';
        let lastHidHex = '';
        let lastHidPath = '';
        let lastTimeRemaining = null;
        let pendingUpdate = null;
        let updateDebounceTimer = null;
        let timeHistory = [];

        // ======================
        // Theme Management
        // ======================
        function initTheme() {
            const savedTheme = localStorage.getItem('theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            
            if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
                document.documentElement.classList.add('dark');
                document.body.classList.remove('light');
                document.body.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
                document.body.classList.add('light');
                document.body.classList.remove('dark');
            }
        }

        function toggleTheme() {
            const isDark = document.documentElement.classList.contains('dark');
            if (isDark) {
                document.documentElement.classList.remove('dark');
                document.body.classList.remove('dark');
                document.body.classList.add('light');
                localStorage.setItem('theme', 'light');
            } else {
                document.documentElement.classList.add('dark');
                document.body.classList.remove('light');
                document.body.classList.add('dark');
                localStorage.setItem('theme', 'dark');
            }
            renderHistory();
        }

        // Listen for system theme changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
            if (!localStorage.getItem('theme')) {
                if (e.matches) {
                    document.documentElement.classList.add('dark');
                    document.body.classList.remove('light');
                    document.body.classList.add('dark');
                } else {
                    document.documentElement.classList.remove('dark');
                    document.body.classList.add('light');
                    document.body.classList.remove('dark');
                }
            }
            renderHistory();
        });

        // ======================
        // Utility Functions
        // ======================
        function clamp(n, min, max) {
            return Math.max(min, Math.min(max, n));
        }

        function parseTime(timeStr) {
            if (!timeStr || timeStr === 'Calculating...') return null;
            const match = timeStr.match(/(\d+)h\s*(\d+)m|(\d+)m/);
            if (!match) return null;
            if (match[1]) return parseInt(match[1]) * 60 + parseInt(match[2]);
            return parseInt(match[3]);
        }

        function formatTime(minutes) {
            if (minutes >= 60) {
                const h = Math.floor(minutes / 60);
                const m = minutes % 60;
                return `${h}h ${m}m`;
            }
            return `${minutes}m`;
        }

        function smoothTime(newTime) {
            if (!newTime || newTime === 'Calculating...') {
                timeHistory = [];
                return newTime;
            }
            const minutes = parseTime(newTime);
            if (minutes === null) return newTime;
            timeHistory.push(minutes);
            if (timeHistory.length > 10) timeHistory.shift();
            if (timeHistory.length < 3) return newTime;
            const sorted = [...timeHistory].sort((a, b) => a - b);
            const median = sorted[Math.floor(sorted.length / 2)];
            return formatTime(median);
        }

        // ======================
        // Battery Visualization
        // ======================
        const BATTERY_RING_RADIUS = 85;
        const BATTERY_RING_CIRCUMFERENCE = 2 * Math.PI * BATTERY_RING_RADIUS;
        const gaugeElements = {
            ring: document.getElementById('batteryRing'),
            level: document.getElementById('batteryLevel'),
            badge: document.getElementById('statusBadge'),
            statusText: document.getElementById('statusText'),
            icon: document.getElementById('batteryIcon'),
        };

        const gaugeState = {
            level: null,
            connected: false,
            charging: false,
            lastKnown: false,
            reading: false,
        };

        const gaugeAnimation = {
            target: 0,
            current: 0,
            frame: null,
        };

        let gaugeRenderQueued = false;

        const gaugeLastRender = {
            levelText: gaugeElements.level ? gaugeElements.level.textContent : null,
            statusText: gaugeElements.statusText ? gaugeElements.statusText.textContent : null,
            badgeClass: gaugeElements.badge ? gaugeElements.badge.className : '',
            ringClass: gaugeElements.ring ? gaugeElements.ring.className : '',
            iconMarkup: gaugeElements.icon ? gaugeElements.icon.innerHTML : '',
        };

        const GAUGE_BADGE_BASE = 'px-4 py-2 rounded-full text-sm font-semibold';
        const BADGE_VARIANTS = {
            neutral: `${GAUGE_BADGE_BASE} bg-gray-200 dark:bg-gray-800 text-gray-600 dark:text-gray-400`,
            good: `${GAUGE_BADGE_BASE} bg-green-100 dark:bg-green-900/30 text-green-700 dark:text-green-300`,
            warning: `${GAUGE_BADGE_BASE} bg-yellow-100 dark:bg-yellow-900/30 text-yellow-700 dark:text-yellow-300`,
            danger: `${GAUGE_BADGE_BASE} bg-red-100 dark:bg-red-900/30 text-red-700 dark:text-red-300`,
            info: `${GAUGE_BADGE_BASE} bg-blue-100 dark:bg-blue-900/30 text-blue-700 dark:text-blue-300`,
        };

        const ICON_BATTERY = `<svg class="w-12 h-12 text-fluent-text dark:text-fluent-dark-text" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <rect x="2" y="7" width="18" height="11" rx="2"/>
                    <path d="M22 10v4"/>
                </svg>`;

        const ICON_BATTERY_LOW = `<svg class="w-12 h-12 text-fluent-text dark:text-fluent-dark-text" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <rect x="2" y="7" width="18" height="11" rx="2"/>
                    <path d="M22 10v4"/>
                    <line x1="6" y1="12" x2="10" y2="12" stroke-width="3"/>
                </svg>`;

        const ICON_CHARGING = `<svg class="w-12 h-12 text-blue-500 dark:text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/>
                </svg>`;

        const ICON_DISCONNECTED = `<svg class="w-12 h-12 text-gray-400 dark:text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <circle cx="12" cy="12" r="10"/>
                    <line x1="8" y1="12" x2="16" y2="12"/>
                </svg>`;

        function updateGaugeState(partial) {
            let shouldRender = false;
            const prevLevel = gaugeState.level;

            if (Object.prototype.hasOwnProperty.call(partial, 'level')) {
                const normalized = normalizeLevelValue(partial.level);
                if (normalized !== gaugeState.level) {
                    gaugeState.level = normalized;
                    shouldRender = true;
                    const immediate = prevLevel === null && normalized !== null;
                    setGaugeTargetLevel(normalized, immediate);
                }
            }

            if (Object.prototype.hasOwnProperty.call(partial, 'connected') && !!partial.connected !== gaugeState.connected) {
                gaugeState.connected = !!partial.connected;
                shouldRender = true;
            }

            if (Object.prototype.hasOwnProperty.call(partial, 'charging') && !!partial.charging !== gaugeState.charging) {
                gaugeState.charging = !!partial.charging;
                shouldRender = true;
            }

            if (Object.prototype.hasOwnProperty.call(partial, 'lastKnown') && !!partial.lastKnown !== gaugeState.lastKnown) {
                gaugeState.lastKnown = !!partial.lastKnown;
                shouldRender = true;
            }

            if (Object.prototype.hasOwnProperty.call(partial, 'reading') && !!partial.reading !== gaugeState.reading) {
                gaugeState.reading = !!partial.reading;
                shouldRender = true;
            }

            if (shouldRender) {
                queueGaugeRender();
            }
        }

        function queueGaugeRender() {
            if (gaugeRenderQueued) {
                return;
            }
            gaugeRenderQueued = true;
            requestAnimationFrame(() => {
                gaugeRenderQueued = false;
                renderBatteryGauge();
            });
        }

        function renderBatteryGauge() {
            const visual = deriveGaugeVisual(gaugeState, gaugeLastRender);
            applyGaugeVisual(visual);
        }

        function deriveGaugeVisual(state, previous = {}) {
            const level = typeof state.level === 'number' ? clamp(state.level, 0, 100) : null;
            const connected = !!state.connected;
            const charging = !!state.charging;
            const lastKnown = !!state.lastKnown;
            const reading = !!state.reading;

            if (reading) {
                const levelText = level !== null ? `${level}%` : 'Reading...';
                return {
                    levelText,
                    statusText: 'Reading...',
                    badgeClass: BADGE_VARIANTS.neutral,
                    ringClass: previous.ringClass || 'battery-ring text-gray-400 dark:text-gray-600',
                    iconMarkup: previous.iconMarkup || ICON_BATTERY,
                };
            }

            if (!connected) {
                if (lastKnown && level !== null) {
                    return {
                        levelText: `${level}%`,
                        statusText: 'Last Known',
                        badgeClass: BADGE_VARIANTS.neutral,
                        ringClass: 'battery-ring text-gray-400 dark:text-gray-600',
                        iconMarkup: ICON_DISCONNECTED,
                    };
                }
                return {
                    levelText: '--',
                    statusText: 'Not Connected',
                    badgeClass: BADGE_VARIANTS.neutral,
                    ringClass: 'battery-ring text-gray-400 dark:text-gray-600',
                    iconMarkup: ICON_DISCONNECTED,
                };
            }

            const levelText = level !== null ? `${level}%` : '--';

            if (charging) {
                return {
                    levelText,
                    statusText: 'Charging',
                    badgeClass: BADGE_VARIANTS.info,
                    ringClass: 'battery-ring text-blue-500 dark:text-blue-400',
                    iconMarkup: ICON_CHARGING,
                };
            }

            if (level === null) {
                return {
                    levelText,
                    statusText: 'Good',
                    badgeClass: BADGE_VARIANTS.good,
                    ringClass: 'battery-ring text-green-500 dark:text-green-400',
                    iconMarkup: ICON_BATTERY,
                };
            }

            if (level >= 50) {
                return {
                    levelText,
                    statusText: 'Good',
                    badgeClass: BADGE_VARIANTS.good,
                    ringClass: 'battery-ring text-green-500 dark:text-green-400',
                    iconMarkup: ICON_BATTERY,
                };
            }
            if (level >= 20) {
                return {
                    levelText,
                    statusText: 'Fair',
                    badgeClass: BADGE_VARIANTS.warning,
                    ringClass: 'battery-ring text-yellow-500 dark:text-yellow-400',
                    iconMarkup: ICON_BATTERY,
                };
            }
            return {
                levelText,
                statusText: 'Low',
                badgeClass: BADGE_VARIANTS.danger,
                ringClass: 'battery-ring text-red-500 dark:text-red-400',
                iconMarkup: ICON_BATTERY_LOW,
            };
        }
        if (typeof window !== 'undefined') {
            window.__deriveGaugeVisual = deriveGaugeVisual;
        }

        function applyGaugeVisual(visual) {
            if (gaugeElements.level && visual.levelText !== gaugeLastRender.levelText) {
                gaugeElements.level.textContent = visual.levelText;
                gaugeLastRender.levelText = visual.levelText;
            }
            if (gaugeElements.statusText && visual.statusText !== gaugeLastRender.statusText) {
                gaugeElements.statusText.textContent = visual.statusText;
                gaugeLastRender.statusText = visual.statusText;
            }
            if (gaugeElements.badge && visual.badgeClass !== gaugeLastRender.badgeClass) {
                gaugeElements.badge.className = visual.badgeClass;
                gaugeLastRender.badgeClass = visual.badgeClass;
            }
            if (gaugeElements.ring && visual.ringClass !== gaugeLastRender.ringClass) {
                gaugeElements.ring.className = visual.ringClass;
                gaugeLastRender.ringClass = visual.ringClass;
            }
            if (gaugeElements.icon && visual.iconMarkup !== gaugeLastRender.iconMarkup) {
                gaugeElements.icon.innerHTML = visual.iconMarkup;
                gaugeLastRender.iconMarkup = visual.iconMarkup;
            }
        }

        function setGaugeTargetLevel(level, immediate) {
            const normalized = typeof level === 'number' ? clamp(level, 0, 100) : 0;
            gaugeAnimation.target = normalized;
            if (immediate) {
                if (gaugeAnimation.frame !== null) {
                    cancelAnimationFrame(gaugeAnimation.frame);
                    gaugeAnimation.frame = null;
                }
                gaugeAnimation.current = normalized;
                applyRingOffset(normalized);
                return;
            }
            if (gaugeAnimation.frame === null) {
                gaugeAnimation.frame = requestAnimationFrame(stepGaugeAnimation);
            }
        }

        function stepGaugeAnimation() {
            const diff = gaugeAnimation.target - gaugeAnimation.current;
            if (Math.abs(diff) <= 0.25) {
                gaugeAnimation.current = gaugeAnimation.target;
                applyRingOffset(gaugeAnimation.current);
                gaugeAnimation.frame = null;
                return;
            }
            gaugeAnimation.current += diff * 0.18;
            applyRingOffset(gaugeAnimation.current);
            gaugeAnimation.frame = requestAnimationFrame(stepGaugeAnimation);
        }

        function applyRingOffset(level) {
            if (!gaugeElements.ring) {
                return;
            }
            const clampedLevel = clamp(level, 0, 100);
            const offset = BATTERY_RING_CIRCUMFERENCE * (1 - clampedLevel / 100);
            gaugeElements.ring.style.strokeDashoffset = offset.toFixed(2);
        }

        function normalizeLevelValue(value) {
            if (value === null || value === undefined || value === '') {
                return null;
            }
            const num = Number(value);
            if (!Number.isFinite(num)) {
                return null;
            }
            return clamp(Math.round(num), 0, 100);
        }

        function resolveLastKnownLevel(payload) {
            if (!payload) {
                return null;
            }
            if (payload.lastKnown && payload.level !== undefined && payload.level !== null) {
                const direct = normalizeLevelValue(payload.level);
                if (direct !== null) {
                    return direct;
                }
            }
            if (payload.lastChargeLevel !== undefined && payload.lastChargeLevel !== null) {
                const fromCharge = normalizeLevelValue(payload.lastChargeLevel);
                if (fromCharge !== null) {
                    return fromCharge;
                }
            }
            return null;
        }

        function formatChargeLevelText(value) {
            if (value === undefined || value === null || value === '') {
                return '--%';
            }
            const normalized = normalizeLevelValue(value);
            if (normalized !== null) {
                return `${normalized}%`;
            }
            if (typeof value === 'string') {
                return value.includes('%') ? value : `${value}%`;
            }
            return `${value}%`;
        }

        // ======================
        // History Graph
        // ======================
        function drawRoundedRect(ctx, x, y, width, height, radius) {
            if (typeof ctx.roundRect === 'function') {
                ctx.roundRect(x, y, width, height, radius);
            } else {
                ctx.moveTo(x + radius, y);
                ctx.lineTo(x + width - radius, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                ctx.lineTo(x + width, y + height - radius);
                ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                ctx.lineTo(x + radius, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                ctx.lineTo(x, y + radius);
                ctx.quadraticCurveTo(x, y, x + radius, y);
                ctx.closePath();
            }
        }

        const HISTORY_RANGE_LABELS = {
            '1h': 'Last hour',
            '6h': 'Last 6 hours',
            '12h': 'Last 12 hours',
            '24h': 'Last 24 hours',
            '72h': 'Last 72 hours',
            '7d': 'Last 7 days'
        };

        function initHistory() {
            historyCanvas = document.getElementById('historyCanvas');
            if (!historyCanvas) {
                return;
            }
            historyCtx = historyCanvas.getContext('2d');
            historyTooltip = document.getElementById('historyGraphTooltip');
            historySummaryEl = document.getElementById('historySummary');
            historyDetailEl = document.getElementById('historyDetail');
            historyUpdatedEl = document.getElementById('historyUpdated');
            historyContainer = document.getElementById('historyGraphContainer');
            historyRangeButtons = Array.from(document.querySelectorAll('.history-range-btn'));
            historyRangeButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const range = btn.dataset.historyRange;
                    if (!range || range === historyState.range) return;
                    historyState.range = range;
                    highlightHistoryRange(range);
                    fetchHistory(range, true);
                });
            });
            historyCanvas.addEventListener('mousemove', handleHistoryHover);
            historyCanvas.addEventListener('mouseleave', hideHistoryTooltip);
            window.addEventListener('resize', () => renderHistory());
            highlightHistoryRange(historyState.range);
            highlightHistoryRange('24h');
            fetchHistory('24h', true);
            renderHistory();
        }

        function highlightHistoryRange(range) {
            historyRangeButtons.forEach(btn => {
                const isActive = btn.dataset.historyRange === range;
                btn.classList.toggle('bg-fluent-accent', isActive);
                btn.classList.toggle('dark:bg-fluent-dark-accent', isActive);
                btn.classList.toggle('text-white', isActive);
                btn.classList.toggle('border-transparent', isActive);
                btn.classList.toggle('text-fluent-muted', !isActive);
                btn.classList.toggle('dark:text-fluent-dark-muted', !isActive);
                btn.classList.toggle('border-fluent-border', !isActive);
                btn.classList.toggle('dark:border-fluent-dark-border', !isActive);
                btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
            });
        }

        function scheduleHistoryFetch(delay = 240) {
            if (historyFetchTimer) {
                clearTimeout(historyFetchTimer);
            }
            historyFetchTimer = setTimeout(() => {
                fetchHistory(historyState.range);
            }, delay);
        }

        async function fetchHistory(range = historyState.range, force = false) {
            if (historyState.fetching && !force) {
                return;
            }
            if (historyFetchTimer) {
                clearTimeout(historyFetchTimer);
                historyFetchTimer = null;
            }
            historyState.fetching = true;
            try {
                const response = await fetch(`/api/history?range=${encodeURIComponent(range)}`);
                if (!response.ok) {
                    throw new Error('Failed to load history');
                }
                const payload = await response.json();
                historyState.points = Array.isArray(payload.points) ? payload.points : [];
                historyState.events = Array.isArray(payload.events) ? payload.events : [];
                historyState.from = Number(payload.from) || 0;
                historyState.to = Number(payload.to) || Date.now();
                historyState.renderedVersion = Number(payload.version) || historyState.renderedVersion;
                historyState.currentVersion = Math.max(historyState.currentVersion, historyState.renderedVersion);
                historyState.range = payload.range || range;
                historyState.hoverIndex = null;
                if (historyTooltip) {
                    historyTooltip.classList.add('hidden');
                }
                highlightHistoryRange(historyState.range);
                updateHistorySummary();
                renderHistory();
            } catch (err) {
                if (historyDetailEl) {
                    historyDetailEl.textContent = 'Unable to load history';
                }
                console.error(err);
            } finally {
                historyState.fetching = false;
                if (historyState.pendingVersion) {
                    historyState.pendingVersion = false;
                    scheduleHistoryFetch(120);
                }
            }
        }

        function renderHistory() {
            if (!historyCanvas || !historyCtx) {
                return;
            }
            const isDark = document.body.classList.contains('dark');

            const width = historyCanvas.clientWidth || historyCanvas.offsetWidth || 320;
            const height = historyCanvas.clientHeight || historyCanvas.offsetHeight || 160;
            const dpr = window.devicePixelRatio || 1;

            if (historyCanvas.width !== Math.floor(width * dpr) || historyCanvas.height !== Math.floor(height * dpr)) {
                historyCanvas.width = Math.floor(width * dpr);
                historyCanvas.height = Math.floor(height * dpr);
            }
            historyCtx.setTransform(1, 0, 0, 1, 0, 0);
            historyCtx.scale(dpr, dpr);

            historyCtx.clearRect(0, 0, width, height);

            const padding = { top: 16, right: 50, bottom: 28, left: 28 };
            const drawWidth = Math.max(10, width - padding.left - padding.right);
            const drawHeight = Math.max(10, height - padding.top - padding.bottom);

            historyCtx.fillStyle = isDark ? 'rgba(15, 23, 42, 0.35)' : 'rgba(255, 255, 255, 0.9)';
            historyCtx.fillRect(0, 0, width, height);

            const points = historyState.points;
            if (!points || points.length < 2) {
                historyCtx.fillStyle = isDark ? 'rgba(255,255,255,0.55)' : 'rgba(15,23,42,0.6)';
                historyCtx.font = '12px "Segoe UI", system-ui, sans-serif';
                historyCtx.textBaseline = 'middle';
                historyCtx.fillText('Waiting for more battery data…', padding.left, height / 2);
                return;
            }

            const levels = points.map(p => Number(p.level) || 0);
            let minLevel = Math.min(...levels, 0);
            let maxLevel = Math.max(...levels, 100);

            if (maxLevel - minLevel < 8) {
                const center = (maxLevel + minLevel) / 2;
                minLevel = center - 4;
                maxLevel = center + 4;
            }
            minLevel = Math.max(0, minLevel - 2);
            maxLevel = Math.min(100, maxLevel + 2);
            const levelRange = maxLevel - minLevel || 1;

            const minTs = historyState.from || points[0].ts;
            const maxTs = historyState.to || points[points.length - 1].ts || (minTs + 60_000);
            const span = Math.max(1, maxTs - minTs);

            const xFor = (ts) => padding.left + ((ts - minTs) / span) * drawWidth;
            const yFor = (level) => padding.top + (1 - ((level - minLevel) / levelRange)) * drawHeight;

            // Grid lines
            const gridLevels = [0, 25, 50, 75, 100];
            historyCtx.strokeStyle = isDark ? 'rgba(255,255,255,0.08)' : 'rgba(15,23,42,0.08)';
            historyCtx.lineWidth = 1;
            historyCtx.setLineDash([4, 4]);
            gridLevels.forEach(lvl => {
                const y = yFor(lvl);
                historyCtx.beginPath();
                historyCtx.moveTo(padding.left, y);
                historyCtx.lineTo(width - padding.right, y);
                historyCtx.stroke();
            });
            historyCtx.setLineDash([]);

            // Charging segments
            let idx = 0;
            while (idx < points.length) {
                if (!points[idx].charging) {
                    idx++;
                    continue;
                }
                const startTs = points[idx].ts;
                let endIndex = idx + 1;
                while (endIndex < points.length && points[endIndex].charging) {
                    endIndex++;
                }
                const endTs = points[Math.min(endIndex, points.length - 1)].ts;
                const xStart = xFor(startTs);
                const xEnd = xFor(endTs);
                historyCtx.fillStyle = isDark ? 'rgba(96,165,250,0.16)' : 'rgba(59,130,246,0.14)';
                historyCtx.fillRect(xStart, padding.top, Math.max(2, xEnd - xStart), drawHeight);
                idx = endIndex;
            }

            const smoothed = points.map((p, i) => {
                let sum = 0;
                let count = 0;
                for (let j = Math.max(0, i - 2); j <= Math.min(points.length - 1, i + 2); j++) {
                    sum += Number(points[j].level) || 0;
                    count++;
                }
                return count ? sum / count : Number(p.level) || 0;
            });

            // Area fill
            historyCtx.beginPath();
            historyCtx.moveTo(xFor(points[0].ts), yFor(smoothed[0]));
            for (let i = 1; i < points.length; i++) {
                historyCtx.lineTo(xFor(points[i].ts), yFor(smoothed[i]));
            }
            historyCtx.lineTo(xFor(points[points.length - 1].ts), padding.top + drawHeight);
            historyCtx.lineTo(xFor(points[0].ts), padding.top + drawHeight);
            historyCtx.closePath();
            historyCtx.fillStyle = isDark ? 'rgba(96,165,250,0.12)' : 'rgba(37,99,235,0.14)';
            historyCtx.fill();

            // Line stroke
            historyCtx.beginPath();
            historyCtx.moveTo(xFor(points[0].ts), yFor(smoothed[0]));
            for (let i = 1; i < points.length; i++) {
                historyCtx.lineTo(xFor(points[i].ts), yFor(smoothed[i]));
            }
            historyCtx.strokeStyle = isDark ? '#60a5fa' : '#2563eb';
            historyCtx.lineWidth = 2;
            historyCtx.stroke();

            const latestPoint = points[points.length - 1];
            const latestX = xFor(latestPoint.ts);
            const latestY = yFor(smoothed[smoothed.length - 1]);
            const latestLevel = Number.isFinite(Number(latestPoint.level)) ? Math.round(Number(latestPoint.level)) : null;

            historyCtx.beginPath();
            historyCtx.fillStyle = isDark ? '#60a5fa' : '#1d4ed8';
            historyCtx.arc(latestX, latestY, 4, 0, Math.PI * 2);
            historyCtx.fill();

            if (latestLevel !== null) {
                const labelText = `${latestLevel}%`;
                historyCtx.font = '11px "Segoe UI", system-ui, sans-serif';
                const textMetrics = historyCtx.measureText(labelText);
                const labelPadding = 8;
                const labelWidth = textMetrics.width + labelPadding * 2;
                const labelHeight = 20;
                let labelX = latestX + 12;
                if (labelX + labelWidth > width - padding.right) {
                    labelX = latestX - labelWidth - 12;
                }
                if (labelX < padding.left) {
                    labelX = padding.left;
                }
                let labelY = latestY - labelHeight / 2 - 6;
                if (labelY < padding.top) {
                    labelY = padding.top;
                }
                if (labelY + labelHeight > height - padding.bottom) {
                    labelY = height - padding.bottom - labelHeight;
                }

                historyCtx.fillStyle = isDark ? 'rgba(15, 23, 42, 0.85)' : 'rgba(255, 255, 255, 0.95)';
                historyCtx.strokeStyle = isDark ? 'rgba(96,165,250,0.45)' : 'rgba(37,99,235,0.35)';
                historyCtx.lineWidth = 1;
                historyCtx.beginPath();
                drawRoundedRect(historyCtx, labelX, labelY, labelWidth, labelHeight, 6);
                historyCtx.fill();
                historyCtx.stroke();

                historyCtx.fillStyle = isDark ? '#e2e8f0' : '#1e293b';
                historyCtx.textBaseline = 'middle';
                historyCtx.textAlign = 'left';
                const textX = labelX + labelPadding;
                const textY = labelY + labelHeight / 2;
                historyCtx.fillText(labelText, textX, textY);
            }

            if (historyState.hoverIndex !== null && points[historyState.hoverIndex]) {
                const index = historyState.hoverIndex;
                const x = xFor(points[index].ts);
                const y = yFor(smoothed[index]);
                historyCtx.beginPath();
                historyCtx.fillStyle = isDark ? '#f8fafc' : '#0f172a';
                historyCtx.arc(x, y, 4.5, 0, Math.PI * 2);
                historyCtx.fill();
                historyCtx.beginPath();
                historyCtx.strokeStyle = isDark ? '#60a5fa' : '#1d4ed8';
                historyCtx.lineWidth = 2;
                historyCtx.arc(x, y, 6, 0, Math.PI * 2);
                historyCtx.stroke();
            }
        }

        function handleHistoryHover(event) {
            if (!historyCanvas || !historyContainer || !historyState.points.length) {
                return;
            }
            const rect = historyCanvas.getBoundingClientRect();
            const containerRect = historyContainer.getBoundingClientRect();
            const relativeX = event.clientX - rect.left;
            const ratio = Math.min(Math.max(relativeX / rect.width, 0), 1);
            const minTs = historyState.from || 0;
            const span = Math.max(1, (historyState.to || Date.now()) - minTs);
            const ts = minTs + ratio * span;

            let nearestIndex = 0;
            let minDiff = Number.POSITIVE_INFINITY;
            historyState.points.forEach((point, idx) => {
                const diff = Math.abs(point.ts - ts);
                if (diff < minDiff) {
                    minDiff = diff;
                    nearestIndex = idx;
                }
            });
            historyState.hoverIndex = nearestIndex;
            renderHistory();

            const point = historyState.points[nearestIndex];
            if (!point) {
                hideHistoryTooltip();
                return;
            }

            const levelValue = Number(point.level);
            const level = Number.isFinite(levelValue) ? levelValue : 0;

            const statusLabel = point.charging ? 'Charging' : 'Battery';
            const timestamp = new Date(point.ts);
            const timeLabel = timestamp.toLocaleTimeString(undefined, { hour: 'numeric', minute: '2-digit' });
            const levelDisplay = Number.isFinite(levelValue) ? level.toFixed(0) : '--';

            let tooltipHtml = `<div class="text-sm font-semibold">${levelDisplay}% ${statusLabel}</div>`;
            tooltipHtml += `<div class="text-xs opacity-80">${timeLabel}</div>`;

            historyTooltip.innerHTML = tooltipHtml;
            historyTooltip.classList.remove('hidden');
            const tooltipRect = historyTooltip.getBoundingClientRect();
            let left = event.clientX - containerRect.left + 12;
            let top = event.clientY - containerRect.top - tooltipRect.height - 12;

            if (left + tooltipRect.width > containerRect.width) {
                left = containerRect.width - tooltipRect.width - 12;
            }
            if (top < 0) {
                top = 0;
            }
            historyTooltip.style.left = `${left}px`;
            historyTooltip.style.top = `${top}px`;
        }

        function hideHistoryTooltip() {
            historyState.hoverIndex = null;
            if (historyTooltip) {
                historyTooltip.classList.add('hidden');
            }
            renderHistory();
        }

        function updateHistorySummary() {
            if (!historySummaryEl || !historyDetailEl || !historyUpdatedEl) {
                return;
            }
            const label = HISTORY_RANGE_LABELS[historyState.range] || 'History';
            const count = historyState.points.length;
            if (!count) {
                historySummaryEl.textContent = `${label} · collecting data`;
                historyDetailEl.textContent = 'Waiting for telemetry…';
                historyUpdatedEl.textContent = '';
                return;
            }
            const startLevel = Number(historyState.points[0].level) || 0;
            const endLevel = Number(historyState.points[count - 1].level) || 0;
            const delta = endLevel - startLevel;
            const deltaText = `${delta >= 0 ? '+' : ''}${delta.toFixed(1).replace(/\.0$/, '')}%`;
            historySummaryEl.textContent = `${label} · ${count} sample${count === 1 ? '' : 's'}`;
            historyDetailEl.textContent = `${Math.round(startLevel)}% → ${Math.round(endLevel)}% (${deltaText})`;
            const relative = formatRelativeTime(historyState.to);
            historyUpdatedEl.textContent = relative ? `Updated ${relative}` : '';
        }

        function formatRate(value) {
            if (!Number.isFinite(value) || Math.abs(value) < 0.05) {
                return '±0%/h';
            }
            const rounded = value.toFixed(1);
            return `${value > 0 ? '+' : ''}${rounded}%/h`;
        }

        function formatRelativeTime(ts) {
            const timestamp = Number(ts);
            if (!timestamp) {
                return '';
            }
            const delta = Date.now() - timestamp;
            if (delta < 60_000) {
                return 'just now';
            }
            if (delta < 3_600_000) {
                const mins = Math.round(delta / 60_000);
                return `${mins} min ago`;
            }
            if (delta < 86_400_000) {
                const hrs = Math.round(delta / 3_600_000);
                return `${hrs} hr${hrs === 1 ? '' : 's'} ago`;
            }
            const date = new Date(timestamp);
            return date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
        }

        function handleHistoryVersion(version) {
            if (!Number.isFinite(version) || version <= 0) {
                return;
            }
            if (version > historyState.currentVersion) {
                historyState.currentVersion = version;
            }
            if (historyState.fetching) {
                historyState.pendingVersion = true;
                return;
            }
            if (historyState.renderedVersion === 0 || version > historyState.renderedVersion) {
                scheduleHistoryFetch();
            }
        }

        // ======================
        // SSE Updates with Debouncing
        // ======================
        let lastPositiveUpdate = 0;

        function debounceUpdate(data) {
            pendingUpdate = data;
            
            if (updateDebounceTimer) {
                clearTimeout(updateDebounceTimer);
            }
            
            updateDebounceTimer = setTimeout(() => {
                if (pendingUpdate) {
                    applyUpdate(pendingUpdate);
                    pendingUpdate = null;
                }
            }, 150); // 150ms debounce for smooth updates
        }

        function applyUpdate(data) {
            if (!data) {
                return;
            }

            const normalizedLevel = normalizeLevelValue(data.level);
            const fallbackLevel = resolveLastKnownLevel(data);
            let antiFlickerLevel = normalizedLevel;
            if (antiFlickerLevel === null || antiFlickerLevel === 0) {
                antiFlickerLevel = fallbackLevel;
            }

            if (data.status === 'disconnected' && (antiFlickerLevel === null || antiFlickerLevel === 0) && lastPositiveUpdate !== 0) {
                const age = Date.now() - lastPositiveUpdate;
                if (age < 6000) {
                    return;
                }
            }

            if (typeof data.historyVersion === 'number') {
                handleHistoryVersion(Number(data.historyVersion));
            }

            const deviceTitle = document.getElementById('deviceTitle');

            if (data.updateAvailable && data.updateVersion) {
                document.getElementById('updateBanner').classList.remove('hidden');
                document.getElementById('updateVersion').textContent = `Version ${data.updateVersion} is ready to install`;
            }

            if (data.deviceModel && data.deviceModel !== 'Unknown') {
                deviceTitle.textContent = 'Glorious ' + data.deviceModel;
            }

            const status = data.status || (data.connected ? 'connected' : 'disconnected');
            const isConnected = status === 'connected';
            const isReading = !!data.reading;

            if (isReading) {
                if (fallbackLevel !== null && fallbackLevel > 0) {
                    lastPositiveUpdate = Date.now();
                }
                const gaugeUpdate = {
                    reading: true,
                    connected: isConnected,
                    charging: !!data.charging,
                    lastKnown: fallbackLevel !== null,
                };
                if (fallbackLevel !== null) {
                    gaugeUpdate.level = fallbackLevel;
                }
                updateGaugeState(gaugeUpdate);
                return;
            }

            updateGaugeState({ reading: false });

            if (isConnected && data.lastKnown && normalizedLevel !== null) {
                if (normalizedLevel > 0) {
                    lastPositiveUpdate = Date.now();
                }
                updateGaugeState({
                    connected: false,
                    charging: !!data.charging,
                    lastKnown: true,
                    level: normalizedLevel,
                    reading: false,
                });
                return;
            }

            if (!isConnected) {
                if (fallbackLevel !== null && fallbackLevel > 0) {
                    lastPositiveUpdate = Date.now();
                }
                updateGaugeState({
                    connected: false,
                    charging: fallbackLevel !== null ? !!data.charging : false,
                    lastKnown: fallbackLevel !== null,
                    level: fallbackLevel,
                    reading: false,
                });

                if (data.lastChargeTime && data.lastChargeTime !== 'Never') {
                    document.getElementById('lastCharge').textContent = data.lastChargeTime;
                    document.getElementById('chargeLevel').textContent = formatChargeLevelText(data.lastChargeLevel);
                }
                return;
            }

            if (normalizedLevel !== null && normalizedLevel > 0) {
                lastPositiveUpdate = Date.now();
            }

            updateGaugeState({
                connected: true,
                charging: !!data.charging,
                lastKnown: false,
                level: normalizedLevel,
                reading: false,
            });

            if (data.lastChargeTime && data.lastChargeTime !== 'Never') {
                document.getElementById('lastCharge').textContent = data.lastChargeTime;
                document.getElementById('chargeLevel').textContent = formatChargeLevelText(data.lastChargeLevel);
            }

            const timeRemainingCard = document.getElementById('timeRemainingCard');
            const timeRemaining = document.getElementById('timeRemaining');
            const timeLabel = document.getElementById('timeLabel');

            if (data.timeRemaining) {
                const smoothed = smoothTime(data.timeRemaining);
                if (smoothed && smoothed !== '' && smoothed !== 'Calculating...') {
                    lastTimeRemaining = smoothed;
                }
            }

            if (lastTimeRemaining) {
                timeRemaining.textContent = lastTimeRemaining;
                timeLabel.textContent = data.charging ? 'Time to Full' : 'Time Remaining';
                timeRemainingCard.classList.remove('hidden');
            } else {
                timeRemainingCard.classList.add('hidden');
            }
        }

        // ======================
        // Settings Management
        // ======================
        async function loadSettings() {
            try {
                const response = await fetch('/api/settings');
                currentSettings = await response.json();
                document.getElementById('startWithWindows').checked = !!currentSettings.startWithWindows;
                document.getElementById('startMinimized').checked = !!currentSettings.startMinimized;
                document.getElementById('nonIntrusiveMode').checked = !!currentSettings.nonIntrusiveMode;
                document.getElementById('safeMode').checked = currentSettings.safeMode !== false;
                document.getElementById('refreshInterval').value = currentSettings.refreshInterval ?? 5;
                document.getElementById('notificationsEnabled').checked = !!currentSettings.notificationsEnabled;
                document.getElementById('lowBatteryThreshold').value = currentSettings.lowBatteryThreshold ?? 20;
                document.getElementById('criticalBatteryThreshold').value = currentSettings.criticalBatteryThreshold ?? 10;
                document.getElementById('showPercentageOnIcon').checked = !!currentSettings.showPercentageOnIcon;
            } catch (e) {
                showToast('Failed to load settings', 'error');
            }
        }

        function openSettings() {
            loadSettings();
            document.getElementById('settingsModal').classList.remove('hidden');
            setTimeout(() => {
                const modal = document.getElementById('settingsModal');
                const firstInput = modal.querySelector('input, button');
                if (firstInput) firstInput.focus();
            }, 100);
        }

        function closeSettings() {
            document.getElementById('settingsModal').classList.add('hidden');
        }

        async function saveSettings() {
            const saveBtn = document.getElementById('saveBtn');
            const saveSpinner = document.getElementById('saveSpinner');
            const saveText = document.getElementById('saveText');
            
            saveBtn.disabled = true;
            saveSpinner.classList.remove('hidden');
            saveText.textContent = 'Saving...';
            
            const payload = {
                startWithWindows: document.getElementById('startWithWindows').checked,
                startMinimized: document.getElementById('startMinimized').checked,
                refreshInterval: clamp(parseInt(document.getElementById('refreshInterval').value, 10) || 5, 1, 60),
                notificationsEnabled: document.getElementById('notificationsEnabled').checked,
                nonIntrusiveMode: document.getElementById('nonIntrusiveMode').checked,
                safeMode: document.getElementById('safeMode').checked,
                lowBatteryThreshold: clamp(parseInt(document.getElementById('lowBatteryThreshold').value, 10) || 20, 5, 50),
                criticalBatteryThreshold: clamp(parseInt(document.getElementById('criticalBatteryThreshold').value, 10) || 10, 5, 30),
                showPercentageOnIcon: document.getElementById('showPercentageOnIcon').checked
            };
            
            try {
                const res = await fetch('/api/settings', { 
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json' }, 
                    body: JSON.stringify(payload) 
                });
                if (!res.ok) throw new Error('Save failed');
                showToast('Settings saved successfully', 'success');
                closeSettings();
            } catch (e) {
                showToast('Failed to save settings', 'error');
            } finally {
                saveBtn.disabled = false;
                saveSpinner.classList.add('hidden');
                saveText.textContent = 'Save';
            }
        }

        // ======================
        // Developer Tools
        // ======================
        async function scanHIDDevices() {
            const devStatus = document.getElementById('devStatus');
            const hidDump = document.getElementById('hidDump');
            const copyBtn = document.getElementById('copyHidBtn');
            
            devStatus.textContent = 'Scanning all HID devices...';
            devStatus.className = 'text-xs text-fluent-muted dark:text-fluent-dark-muted';
            copyBtn.disabled = true;
            
            try {
                const res = await fetch('/api/scan-hid', { method: 'POST' });
                if (!res.ok) throw new Error(await res.text() || 'Scan failed');
                
                const data = await res.json();
                
                let output = `=== HID Device Scan Results ===\n`;
                output += `Total devices: ${data.totalCount}\n`;
                output += `Glorious devices: ${data.gloriousCount}\n\n`;
                
                if (data.gloriousCount > 0) {
                    output += `--- Glorious Devices ---\n`;
                    data.gloriousDevices.forEach((dev, i) => {
                        output += `\n[${i + 1}] ${dev.modelName}\n`;
                        output += `    VID: ${dev.vendorId}, PID: ${dev.productId}\n`;
                        output += `    Product: ${dev.productStr}\n`;
                        if (dev.manufacturer) output += `    Manufacturer: ${dev.manufacturer}\n`;
                        if (dev.serialNumber) output += `    Serial: ${dev.serialNumber}\n`;
                        output += `    UsagePage: ${dev.usagePage}, Usage: ${dev.usage}\n`;
                        output += `    Interface: ${dev.interfaceNbr}, Release: ${dev.releaseNbr}\n`;
                        output += `    Path: ${dev.path}\n`;
                    });
                    output += `\n`;
                }
                
                output += `--- All HID Devices ---\n`;
                data.allDevices.forEach((dev, i) => {
                    output += `\n[${i + 1}] VID: ${dev.vendorId}, PID: ${dev.productId}`;
                    if (dev.productStr) output += ` - ${dev.productStr}`;
                    output += `\n`;
                    if (dev.manufacturer) output += `    Manufacturer: ${dev.manufacturer}\n`;
                    output += `    UsagePage: ${dev.usagePage}, Usage: ${dev.usage}, Interface: ${dev.interfaceNbr}\n`;
                    if (dev.isGlorious) output += `    ⭐ Glorious Device\n`;
                });
                
                lastHidDump = output;
                hidDump.textContent = output;
                hidDump.classList.remove('hidden');
                
                devStatus.textContent = `Found ${data.totalCount} HID devices (${data.gloriousCount} Glorious)`;
                devStatus.className = 'text-xs text-green-600 dark:text-green-400';
                copyBtn.disabled = false;
                
                showToast(`Scan complete: ${data.gloriousCount} Glorious device(s) found`, 'success');
            } catch (err) {
                devStatus.textContent = err.message;
                devStatus.className = 'text-xs text-red-600 dark:text-red-400';
                showToast(err.message, 'error');
            }
        }

        async function captureHidReport() {
            const devStatus = document.getElementById('devStatus');
            const hidDump = document.getElementById('hidDump');
            const copyBtn = document.getElementById('copyHidBtn');
            
            devStatus.textContent = 'Capturing HID report...';
            devStatus.className = 'text-xs text-fluent-muted dark:text-fluent-dark-muted';
            copyBtn.disabled = true;
            
            try {
                const res = await fetch('/api/devtools/hid-report', { method: 'POST' });
                if (!res.ok) throw new Error(await res.text() || 'Capture failed');
                
                const data = await res.json();
                lastHidDump = data.hexDump || '';
                lastHidHex = data.hex || '';
                lastHidPath = data.path || '';
                
                const content = lastHidDump || lastHidHex;
                hidDump.textContent = content || 'Report captured but empty payload received.';
                hidDump.classList.remove('hidden');
                
                const parts = [];
                if (lastHidPath) parts.push(`Saved to ${lastHidPath}`);
                if (typeof data.length === 'number') parts.push(`${data.length} bytes`);
                if (data.fromCache) parts.push('cached');
                
                devStatus.textContent = parts.length ? parts.join(' • ') : 'Capture complete';
                devStatus.className = data.fromCache 
                    ? 'text-xs text-yellow-600 dark:text-yellow-400' 
                    : 'text-xs text-green-600 dark:text-green-400';
                
                if (lastHidDump || lastHidHex) copyBtn.disabled = false;
                
                showToast(data.fromCache ? 'Used cached HID report' : 'HID report captured', data.fromCache ? 'info' : 'success');
            } catch (err) {
                devStatus.textContent = err.message;
                devStatus.className = 'text-xs text-red-600 dark:text-red-400';
                showToast(err.message, 'error');
            }
        }

        async function copyHidReport() {
            if (!lastHidDump && !lastHidHex) {
                showToast('Nothing to copy yet', 'info');
                return;
            }
            
            const lines = [];
            if (lastHidPath) lines.push(`Path: ${lastHidPath}`);
            if (lastHidHex) lines.push(`Hex: ${lastHidHex}`);
            if (lastHidDump) lines.push('', lastHidDump);
            
            try {
                await navigator.clipboard.writeText(lines.join('\n'));
                showToast('HID report copied to clipboard', 'success');
            } catch (err) {
                showToast('Failed to copy to clipboard', 'error');
            }
        }

        async function captureDiagnostics() {
            const devStatus = document.getElementById('devStatus');
            const diagnosticsSpinner = document.getElementById('diagnosticsSpinner');
            const diagnosticsText = document.getElementById('diagnosticsText');
            const includeExperimental = document.getElementById('includeExperimental').checked;
            
            diagnosticsSpinner.classList.remove('hidden');
            diagnosticsText.textContent = 'Capturing...';
            
            try {
                const res = await fetch('/api/diagnostics', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        includeExperimental: includeExperimental
                    })
                });
                
                if (!res.ok) {
                    const errorText = await res.text();
                    throw new Error(errorText || 'Diagnostics capture failed');
                }
                
                const data = await res.json();
                
                if (data.success) {
                    devStatus.textContent = `Diagnostics saved to ${data.zipPath}`;
                    devStatus.className = 'text-xs text-green-600 dark:text-green-400';
                    showToast(`Diagnostics captured: ${data.devices} device(s) saved`, 'success');
                    
                    // Optionally copy summary to clipboard
                    try {
                        await navigator.clipboard.writeText(data.summary);
                        console.log('Summary copied to clipboard');
                    } catch (err) {
                        console.log('Failed to copy summary to clipboard:', err);
                    }
                } else {
                    throw new Error('Diagnostics capture failed');
                }
            } catch (err) {
                devStatus.textContent = err.message;
                devStatus.className = 'text-xs text-red-600 dark:text-red-400';
                showToast(err.message, 'error');
            } finally {
                diagnosticsSpinner.classList.add('hidden');
                diagnosticsText.textContent = 'Capture Diagnostics';
            }
        }

        // ======================
        // Toast Notifications
        // ======================
        function showToast(message, type = 'success') {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            
            const bgClass = type === 'error' ? 'bg-red-100 dark:bg-red-900/30 border-red-300 dark:border-red-700 text-red-800 dark:text-red-200'
                : type === 'info' ? 'bg-blue-100 dark:bg-blue-900/30 border-blue-300 dark:border-blue-700 text-blue-800 dark:text-blue-200'
                : 'bg-green-100 dark:bg-green-900/30 border-green-300 dark:border-green-700 text-green-800 dark:text-green-200';
            
            const icon = type === 'error' ? '⚠️' : type === 'info' ? 'ℹ️' : '✅';
            
            toast.className = `flex items-center gap-3 px-4 py-3 rounded-lg border shadow-lg min-w-[280px] toast-enter ${bgClass}`;
            toast.innerHTML = `
                <span aria-hidden="true">${icon}</span>
                <span class="flex-1 text-sm font-medium">${message}</span>
                <button onclick="this.parentElement.remove()" class="hover:opacity-70 transition focus-ring rounded" aria-label="Dismiss">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                    </svg>
                </button>
            `;
            
            container.appendChild(toast);
            
            setTimeout(() => {
                toast.classList.remove('toast-enter');
                toast.classList.add('toast-exit');
                setTimeout(() => toast.remove(), 200);
            }, 3000);
        }

        // ======================
        // Tooltip
        // ======================
        function toggleTimeTooltip() {
            const tooltip = document.getElementById('timeTooltip');
            const card = document.getElementById('timeRemainingCard');
            
            if (tooltip.classList.contains('hidden')) {
                const rect = card.getBoundingClientRect();
                tooltip.style.left = rect.left + 'px';
                tooltip.style.top = (rect.top - tooltip.offsetHeight - 10) + 'px';
                tooltip.classList.remove('hidden');
                
                setTimeout(() => tooltip.classList.add('hidden'), 4000);
            } else {
                tooltip.classList.add('hidden');
            }
        }

        // Close tooltip when clicking outside
        document.addEventListener('click', (e) => {
            const tooltip = document.getElementById('timeTooltip');
            const card = document.getElementById('timeRemainingCard');
            if (!tooltip.classList.contains('hidden') && !card.contains(e.target)) {
                tooltip.classList.add('hidden');
            }
        });

        // ======================
        // Update Management
        // ======================
        async function installUpdate() {
            const btn = document.getElementById('updateBtn');
            btn.disabled = true;
            btn.textContent = 'Installing...';
            
            try {
                const res = await fetch('/api/update', { method: 'POST' });
                if (!res.ok) throw new Error('Update failed');
                showToast('Update started. App will restart...', 'info');
            } catch (e) {
                showToast('Update failed. Please try again.', 'error');
                btn.disabled = false;
                btn.textContent = 'Install Now';
            }
        }

        // ======================
        // SSE Connection
        // ======================
        const eventSource = new EventSource('/events');
        eventSource.onmessage = function (event) {
            try {
                const data = JSON.parse(event.data);
                debounceUpdate(data);
            } catch (e) {
                console.error('Failed to parse SSE data:', e);
            }
        };

        // ======================
        // Initial Data Fetch
        // ======================
        (async function () {
            try {
                const r = await fetch('/api/status');
                if (r.ok) {
                    const s = await r.json();
                    applyUpdate(s);
                }
            } catch (e) {
                console.warn('Initial status fetch failed', e);
            }
        })();

        // ======================
        // Refresh on Focus
        // ======================
        window.addEventListener('focus', async () => {
            try {
                const r = await fetch('/api/status');
                if (r.ok) applyUpdate(await r.json());
            } catch (e) {}
        });

        document.addEventListener('visibilitychange', async () => {
            if (document.visibilityState === 'visible') {
                try {
                    const r = await fetch('/api/status');
                    if (r.ok) applyUpdate(await r.json());
                } catch (e) {}
            }
        });

        // ======================
        // Periodic Polling Fallback
        // ======================
        setInterval(async () => {
            try {
                const r = await fetch('/api/status');
                if (r.ok) applyUpdate(await r.json());
            } catch (e) {}
        }, 3000);

        // ======================
        // Keyboard Navigation
        // ======================
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeSettings();
                document.getElementById('timeTooltip').classList.add('hidden');
            }
        });

        // ======================
        // Initialize
        // ======================
        initTheme();
        initHistory();
        
        // Initialize battery ring
        const ring = document.getElementById('batteryRing');
        ring.style.strokeDasharray = '534.07';
        ring.style.strokeDashoffset = '534.07';
    </script>
</body>
</html>
